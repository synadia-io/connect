// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package model

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type Component struct {
	// A description of the component
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Fields corresponds to the JSON schema field "fields".
	Fields []ComponentField `json:"fields,omitempty" yaml:"fields,omitempty" mapstructure:"fields,omitempty"`

	// Kind corresponds to the JSON schema field "kind".
	Kind ComponentKind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// A human readable label for the component
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// The name of the component. This field can only contain alphanumeric characters
	// and underscores
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The unique identifier of the runtime to which this component belongs
	RuntimeId string `json:"runtime_id" yaml:"runtime_id" mapstructure:"runtime_id"`

	// Status corresponds to the JSON schema field "status".
	Status ComponentStatus `json:"status" yaml:"status" mapstructure:"status"`
}

type ComponentField struct {
	// Constraints corresponds to the JSON schema field "constraints".
	Constraints []ComponentFieldConstraintsElem `json:"constraints,omitempty" yaml:"constraints,omitempty" mapstructure:"constraints,omitempty"`

	// The default value of the field
	Default interface{} `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// A description of the field
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Examples corresponds to the JSON schema field "examples".
	Examples []interface{} `json:"examples,omitempty" yaml:"examples,omitempty" mapstructure:"examples,omitempty"`

	// Fields corresponds to the JSON schema field "fields".
	Fields []*ComponentField `json:"fields,omitempty" yaml:"fields,omitempty" mapstructure:"fields,omitempty"`

	// The kind of the field
	Kind ComponentFieldKind `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// A human readable label for the field
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// The name of the field. This field can only contain alphanumeric characters and
	// underscores
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// If true, the field is optional
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// The path to the field in the resulting configuration. If no path is provided,
	// the field is assumed to be a grouping of other fields
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// A hint to the renderer on how to render the field
	RenderHint *string `json:"render_hint,omitempty" yaml:"render_hint,omitempty" mapstructure:"render_hint,omitempty"`

	// If true, the value of the field is considered secret and should not be
	// displayed in logs or UIs
	Secret *bool `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`

	// The type of the field
	Type ComponentFieldType `json:"type" yaml:"type" mapstructure:"type"`
}

type ComponentFieldConstraintsElem struct {
	// Enum corresponds to the JSON schema field "enum".
	Enum []string `json:"enum,omitempty" yaml:"enum,omitempty" mapstructure:"enum,omitempty"`

	// A preset which implies the rules to which the value must adhere
	Preset *string `json:"preset,omitempty" yaml:"preset,omitempty" mapstructure:"preset,omitempty"`

	// Range corresponds to the JSON schema field "range".
	Range *ComponentFieldConstraintsElemRange `json:"range,omitempty" yaml:"range,omitempty" mapstructure:"range,omitempty"`

	// A regular expression that the value must match
	Regex *string `json:"regex,omitempty" yaml:"regex,omitempty" mapstructure:"regex,omitempty"`
}

type ComponentFieldConstraintsElemRange struct {
	// If filled in, the value must be greater than this
	Gt *float64 `json:"gt,omitempty" yaml:"gt,omitempty" mapstructure:"gt,omitempty"`

	// If filled in, the value must be greater than or equal to this
	Gte *float64 `json:"gte,omitempty" yaml:"gte,omitempty" mapstructure:"gte,omitempty"`

	// If filled in, the value must be less than this
	Lt *float64 `json:"lt,omitempty" yaml:"lt,omitempty" mapstructure:"lt,omitempty"`

	// If filled in, the value must be less than or equal to this
	Lte *float64 `json:"lte,omitempty" yaml:"lte,omitempty" mapstructure:"lte,omitempty"`
}

type ComponentFieldKind string

const ComponentFieldKindList ComponentFieldKind = "list"
const ComponentFieldKindMap ComponentFieldKind = "map"
const ComponentFieldKindScalar ComponentFieldKind = "scalar"

var enumValues_ComponentFieldKind = []interface{}{
	"scalar",
	"map",
	"list",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentFieldKind) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentFieldKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentFieldKind, v)
	}
	*j = ComponentFieldKind(v)
	return nil
}

type ComponentFieldType string

const ComponentFieldTypeBool ComponentFieldType = "bool"
const ComponentFieldTypeCondition ComponentFieldType = "condition"
const ComponentFieldTypeExpression ComponentFieldType = "expression"
const ComponentFieldTypeInt ComponentFieldType = "int"
const ComponentFieldTypeObject ComponentFieldType = "object"
const ComponentFieldTypeScanner ComponentFieldType = "scanner"
const ComponentFieldTypeString ComponentFieldType = "string"

var enumValues_ComponentFieldType = []interface{}{
	"bool",
	"int",
	"object",
	"scanner",
	"string",
	"expression",
	"condition",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentFieldType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentFieldType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentFieldType, v)
	}
	*j = ComponentFieldType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentField) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in ComponentField: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ComponentField: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ComponentField: required")
	}
	type Plain ComponentField
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		plain.Kind = "scalar"
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]*$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", `^[a-zA-Z0-9_]*$`, "Name")
	}
	*j = ComponentField(plain)
	return nil
}

type ComponentGetRequest struct {
	// The kind of the component
	Kind ComponentKind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// The name of the component. This field can only contain alphanumeric characters
	// and underscores
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The unique identifier of the runtime to which this component belongs
	RuntimeId string `json:"runtime_id" yaml:"runtime_id" mapstructure:"runtime_id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentGetRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in ComponentGetRequest: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ComponentGetRequest: required")
	}
	if _, ok := raw["runtime_id"]; raw != nil && !ok {
		return fmt.Errorf("field runtime_id in ComponentGetRequest: required")
	}
	type Plain ComponentGetRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]*$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", `^[a-zA-Z0-9_]*$`, "Name")
	}
	*j = ComponentGetRequest(plain)
	return nil
}

type ComponentGetResponse struct {
	// Component corresponds to the JSON schema field "component".
	Component Component `json:"component" yaml:"component" mapstructure:"component"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentGetResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["component"]; raw != nil && !ok {
		return fmt.Errorf("field component in ComponentGetResponse: required")
	}
	type Plain ComponentGetResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ComponentGetResponse(plain)
	return nil
}

type ComponentKind string

const ComponentKindScanner ComponentKind = "scanner"
const ComponentKindSink ComponentKind = "sink"
const ComponentKindSource ComponentKind = "source"

var enumValues_ComponentKind = []interface{}{
	"source",
	"sink",
	"scanner",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentKind) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentKind, v)
	}
	*j = ComponentKind(v)
	return nil
}

type ComponentSearchFilter struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind *ComponentKind `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// The unique identifier of the runtime
	RuntimeId *string `json:"runtime_id,omitempty" yaml:"runtime_id,omitempty" mapstructure:"runtime_id,omitempty"`

	// Status corresponds to the JSON schema field "status".
	Status *ComponentStatus `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

type ComponentSearchRequest struct {
	// Filter corresponds to the JSON schema field "filter".
	Filter *ComponentSearchFilter `json:"filter,omitempty" yaml:"filter,omitempty" mapstructure:"filter,omitempty"`
}

type ComponentSearchResponse struct {
	// Components corresponds to the JSON schema field "components".
	Components []ComponentSummary `json:"components,omitempty" yaml:"components,omitempty" mapstructure:"components,omitempty"`
}

type ComponentStatus string

const ComponentStatusDeprecated ComponentStatus = "deprecated"
const ComponentStatusExperimental ComponentStatus = "experimental"
const ComponentStatusPreview ComponentStatus = "preview"
const ComponentStatusStable ComponentStatus = "stable"

var enumValues_ComponentStatus = []interface{}{
	"stable",
	"preview",
	"experimental",
	"deprecated",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentStatus) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentStatus, v)
	}
	*j = ComponentStatus(v)
	return nil
}

type ComponentSummary struct {
	// A description of the component
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Kind corresponds to the JSON schema field "kind".
	Kind ComponentKind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// A human readable label for the component
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// The name of the component. This field can only contain alphanumeric characters
	// and underscores
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The unique identifier of the runtime to which this component belongs
	RuntimeId string `json:"runtime_id" yaml:"runtime_id" mapstructure:"runtime_id"`

	// Status corresponds to the JSON schema field "status".
	Status ComponentStatus `json:"status" yaml:"status" mapstructure:"status"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentSummary) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in ComponentSummary: required")
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in ComponentSummary: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ComponentSummary: required")
	}
	if _, ok := raw["runtime_id"]; raw != nil && !ok {
		return fmt.Errorf("field runtime_id in ComponentSummary: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in ComponentSummary: required")
	}
	type Plain ComponentSummary
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]*$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", `^[a-zA-Z0-9_]*$`, "Name")
	}
	*j = ComponentSummary(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Component) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in Component: required")
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in Component: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Component: required")
	}
	if _, ok := raw["runtime_id"]; raw != nil && !ok {
		return fmt.Errorf("field runtime_id in Component: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in Component: required")
	}
	type Plain Component
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]*$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", `^[a-zA-Z0-9_]*$`, "Name")
	}
	*j = Component(plain)
	return nil
}

type Runtime struct {
	// The author of the runtime
	Author RuntimeAuthor `json:"author" yaml:"author" mapstructure:"author"`

	// A description of the runtime
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The unique identifier of the runtime
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The location of the image to execute
	Image string `json:"image" yaml:"image" mapstructure:"image"`

	// A human readable label for the runtime
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// The metrics configuration of the runtime, if any
	Metrics *RuntimeMetrics `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

// The author of the runtime
type RuntimeAuthor struct {
	// The email address of the author
	Email *string `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// The name of the author
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The url to a website related to the author
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuntimeAuthor) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RuntimeAuthor: required")
	}
	type Plain RuntimeAuthor
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RuntimeAuthor(plain)
	return nil
}

type RuntimeGetRequest struct {
	// The name of the runtime
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuntimeGetRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RuntimeGetRequest: required")
	}
	type Plain RuntimeGetRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RuntimeGetRequest(plain)
	return nil
}

type RuntimeGetResponse struct {
	// Runtime corresponds to the JSON schema field "runtime".
	Runtime Runtime `json:"runtime" yaml:"runtime" mapstructure:"runtime"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuntimeGetResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["runtime"]; raw != nil && !ok {
		return fmt.Errorf("field runtime in RuntimeGetResponse: required")
	}
	type Plain RuntimeGetResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RuntimeGetResponse(plain)
	return nil
}

type RuntimeListRequest map[string]interface{}

type RuntimeListResponse struct {
	// Runtimes corresponds to the JSON schema field "runtimes".
	Runtimes []RuntimeSummary `json:"runtimes,omitempty" yaml:"runtimes,omitempty" mapstructure:"runtimes,omitempty"`
}

// The metrics configuration of the runtime, if any
type RuntimeMetrics struct {
	// The path where metrics can be retrieved
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// The port number where metrics can be retrieved
	Port *int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

type RuntimeSummary struct {
	// The author of the runtime
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// A description of the runtime
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The unique identifier of the runtime
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// A human readable label for the runtime
	Label string `json:"label" yaml:"label" mapstructure:"label"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuntimeSummary) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in RuntimeSummary: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in RuntimeSummary: required")
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in RuntimeSummary: required")
	}
	type Plain RuntimeSummary
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RuntimeSummary(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Runtime) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in Runtime: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Runtime: required")
	}
	if _, ok := raw["image"]; raw != nil && !ok {
		return fmt.Errorf("field image in Runtime: required")
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in Runtime: required")
	}
	type Plain Runtime
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Runtime(plain)
	return nil
}
