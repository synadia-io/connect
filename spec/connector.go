// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package spec

import (
	"encoding/json"
	"fmt"
	"reflect"
)

type ConnectorSpec struct {
	// A description of the connector
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The runtime to use for this connector. The runtime can be suffixed with the
	// version, e.g. 'wombat:edge'
	RuntimeId string `json:"runtime_id" yaml:"runtime_id" mapstructure:"runtime_id"`

	// Steps corresponds to the JSON schema field "steps".
	Steps StepsSpec `json:"steps" yaml:"steps" mapstructure:"steps"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectorSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ConnectorSpec: required")
	}
	if _, ok := raw["runtime_id"]; raw != nil && !ok {
		return fmt.Errorf("field runtime_id in ConnectorSpec: required")
	}
	if _, ok := raw["steps"]; raw != nil && !ok {
		return fmt.Errorf("field steps in ConnectorSpec: required")
	}
	type Plain ConnectorSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConnectorSpec(plain)
	return nil
}

// The consumer reading messages from NATS
type ConsumerStepSpec struct {
	// The configuration for reading from Core NATS subjects
	Core *ConsumerStepSpecCore `json:"core,omitempty" yaml:"core,omitempty" mapstructure:"core,omitempty"`

	// The configuration for reading from the NATS KV store
	Kv *ConsumerStepSpecKv `json:"kv,omitempty" yaml:"kv,omitempty" mapstructure:"kv,omitempty"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The configuration for reading from JetStream streams
	Stream *ConsumerStepSpecStream `json:"stream,omitempty" yaml:"stream,omitempty" mapstructure:"stream,omitempty"`
}

// The configuration for reading from Core NATS subjects
type ConsumerStepSpecCore struct {
	// The queue this connector should join
	Queue *string `json:"queue,omitempty" yaml:"queue,omitempty" mapstructure:"queue,omitempty"`

	// The subject to read messages from
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpecCore) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ConsumerStepSpecCore: required")
	}
	type Plain ConsumerStepSpecCore
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpecCore(plain)
	return nil
}

// The configuration for reading from the NATS KV store
type ConsumerStepSpecKv struct {
	// The bucket to use when reading from the KV store
	Bucket string `json:"bucket" yaml:"bucket" mapstructure:"bucket"`

	// The key to use when reading from the KV store
	Key string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpecKv) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bucket"]; raw != nil && !ok {
		return fmt.Errorf("field bucket in ConsumerStepSpecKv: required")
	}
	type Plain ConsumerStepSpecKv
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		plain.Key = ">"
	}
	*j = ConsumerStepSpecKv(plain)
	return nil
}

// The configuration for reading from JetStream streams
type ConsumerStepSpecStream struct {
	// The subject to consume from
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpecStream) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ConsumerStepSpecStream: required")
	}
	type Plain ConsumerStepSpecStream
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpecStream(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in ConsumerStepSpec: required")
	}
	type Plain ConsumerStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpec(plain)
	return nil
}

// The producer writing messages to NATS
type ProducerStepSpec struct {
	// The configuration for writing to Core NATS subjects
	Core *ProducerStepSpecCore `json:"core,omitempty" yaml:"core,omitempty" mapstructure:"core,omitempty"`

	// The configuration for writing to the NATS KV store
	Kv *ProducerStepSpecKv `json:"kv,omitempty" yaml:"kv,omitempty" mapstructure:"kv,omitempty"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The configuration for writing to JetStream streams
	Stream *ProducerStepSpecStream `json:"stream,omitempty" yaml:"stream,omitempty" mapstructure:"stream,omitempty"`

	// The number of threads used to write messages.
	Threads int `json:"threads,omitempty" yaml:"threads,omitempty" mapstructure:"threads,omitempty"`
}

// The configuration for writing to Core NATS subjects
type ProducerStepSpecCore struct {
	// The subject to send data to
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpecCore) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ProducerStepSpecCore: required")
	}
	type Plain ProducerStepSpecCore
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProducerStepSpecCore(plain)
	return nil
}

// The configuration for writing to the NATS KV store
type ProducerStepSpecKv struct {
	// The bucket to use when writing to the KV store
	Bucket string `json:"bucket" yaml:"bucket" mapstructure:"bucket"`

	// The key to use when writing to the KV store
	Key string `json:"key" yaml:"key" mapstructure:"key"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpecKv) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bucket"]; raw != nil && !ok {
		return fmt.Errorf("field bucket in ProducerStepSpecKv: required")
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in ProducerStepSpecKv: required")
	}
	type Plain ProducerStepSpecKv
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProducerStepSpecKv(plain)
	return nil
}

// The configuration for writing to JetStream streams
type ProducerStepSpecStream struct {
	// The subject to send data to
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpecStream) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ProducerStepSpecStream: required")
	}
	type Plain ProducerStepSpecStream
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProducerStepSpecStream(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in ProducerStepSpec: required")
	}
	type Plain ProducerStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["threads"]; !ok || v == nil {
		plain.Threads = 1.0
	}
	*j = ProducerStepSpec(plain)
	return nil
}

// The external system that is the target for the messages
type SinkStepSpec struct {
	// The configuration of the sink step
	Config SinkStepSpecConfig `json:"config" yaml:"config" mapstructure:"config"`

	// The type of the sink step. This should be a sink that is included in the
	// connector's runtime
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// The configuration of the sink step
type SinkStepSpecConfig map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SinkStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in SinkStepSpec: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SinkStepSpec: required")
	}
	type Plain SinkStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SinkStepSpec(plain)
	return nil
}

// The external system that is the source of the messages
type SourceStepSpec struct {
	// The configuration of the source step
	Config SourceStepSpecConfig `json:"config" yaml:"config" mapstructure:"config"`

	// The type of the source step. This should be a source that is included in the
	// connector's runtime
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// The configuration of the source step
type SourceStepSpecConfig map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in SourceStepSpec: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SourceStepSpec: required")
	}
	type Plain SourceStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SourceStepSpec(plain)
	return nil
}

type StepsSpec struct {
	// Consumer corresponds to the JSON schema field "consumer".
	Consumer *ConsumerStepSpec `json:"consumer,omitempty" yaml:"consumer,omitempty" mapstructure:"consumer,omitempty"`

	// Producer corresponds to the JSON schema field "producer".
	Producer *ProducerStepSpec `json:"producer,omitempty" yaml:"producer,omitempty" mapstructure:"producer,omitempty"`

	// Sink corresponds to the JSON schema field "sink".
	Sink *SinkStepSpec `json:"sink,omitempty" yaml:"sink,omitempty" mapstructure:"sink,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *SourceStepSpec `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Transformer corresponds to the JSON schema field "transformer".
	Transformer *TransformerStepSpec `json:"transformer,omitempty" yaml:"transformer,omitempty" mapstructure:"transformer,omitempty"`
}

// The transformer for messages flowing through the connector
type TransformerStepSpec struct {
	// Combine all messages in the batch into a single message
	Combine *TransformerStepSpecCombine `json:"combine,omitempty" yaml:"combine,omitempty" mapstructure:"combine,omitempty"`

	// A composite transformer which can be used to combine several transformers
	Composite *TransformerStepSpecComposite `json:"composite,omitempty" yaml:"composite,omitempty" mapstructure:"composite,omitempty"`

	// Explode a message with a json array payload into multiple messages
	Explode *TransformerStepSpecExplode `json:"explode,omitempty" yaml:"explode,omitempty" mapstructure:"explode,omitempty"`

	// A mapping transformer which can transform the message
	Mapping *TransformerStepSpecMapping `json:"mapping,omitempty" yaml:"mapping,omitempty" mapstructure:"mapping,omitempty"`

	// A service transformer sends each message to a nats service to be transformed
	Service *TransformerStepSpecService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

// Combine all messages in the batch into a single message
type TransformerStepSpecCombine struct {
	// The format of the payload to explode
	Format TransformerStepSpecCombineFormat `json:"format" yaml:"format" mapstructure:"format"`

	// The path to use for each message in case the format is `tar` or `zip`.
	// Expressions can be used to set a unique path for each message.
	Path string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

type TransformerStepSpecCombineFormat string

const TransformerStepSpecCombineFormatJsonArray TransformerStepSpecCombineFormat = "json_array"
const TransformerStepSpecCombineFormatLines TransformerStepSpecCombineFormat = "lines"
const TransformerStepSpecCombineFormatTar TransformerStepSpecCombineFormat = "tar"
const TransformerStepSpecCombineFormatZip TransformerStepSpecCombineFormat = "zip"

var enumValues_TransformerStepSpecCombineFormat = []interface{}{
	"json_array",
	"lines",
	"tar",
	"zip",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecCombineFormat) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransformerStepSpecCombineFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransformerStepSpecCombineFormat, v)
	}
	*j = TransformerStepSpecCombineFormat(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecCombine) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain TransformerStepSpecCombine
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["format"]; !ok || v == nil {
		plain.Format = "json_array"
	}
	if v, ok := raw["path"]; !ok || v == nil {
		plain.Path = ","
	}
	*j = TransformerStepSpecCombine(plain)
	return nil
}

// A composite transformer which can be used to combine several transformers
type TransformerStepSpecComposite struct {
	// Sequential corresponds to the JSON schema field "sequential".
	Sequential []TransformerStepSpec `json:"sequential" yaml:"sequential" mapstructure:"sequential"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecComposite) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sequential"]; raw != nil && !ok {
		return fmt.Errorf("field sequential in TransformerStepSpecComposite: required")
	}
	type Plain TransformerStepSpecComposite
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TransformerStepSpecComposite(plain)
	return nil
}

// Explode a message with a json array payload into multiple messages
type TransformerStepSpecExplode struct {
	// The delimiter to use for the payload in case format is csv
	Delimiter string `json:"delimiter,omitempty" yaml:"delimiter,omitempty" mapstructure:"delimiter,omitempty"`

	// The format of the payload to explode
	Format TransformerStepSpecExplodeFormat `json:"format" yaml:"format" mapstructure:"format"`
}

type TransformerStepSpecExplodeFormat string

const TransformerStepSpecExplodeFormatCsv TransformerStepSpecExplodeFormat = "csv"
const TransformerStepSpecExplodeFormatJsonArray TransformerStepSpecExplodeFormat = "json_array"
const TransformerStepSpecExplodeFormatJsonDocuments TransformerStepSpecExplodeFormat = "json_documents"
const TransformerStepSpecExplodeFormatJsonMap TransformerStepSpecExplodeFormat = "json_map"
const TransformerStepSpecExplodeFormatLines TransformerStepSpecExplodeFormat = "lines"
const TransformerStepSpecExplodeFormatTar TransformerStepSpecExplodeFormat = "tar"
const TransformerStepSpecExplodeFormatZip TransformerStepSpecExplodeFormat = "zip"

var enumValues_TransformerStepSpecExplodeFormat = []interface{}{
	"csv",
	"json_array",
	"json_map",
	"json_documents",
	"lines",
	"tar",
	"zip",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecExplodeFormat) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransformerStepSpecExplodeFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransformerStepSpecExplodeFormat, v)
	}
	*j = TransformerStepSpecExplodeFormat(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecExplode) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain TransformerStepSpecExplode
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["delimiter"]; !ok || v == nil {
		plain.Delimiter = ","
	}
	if v, ok := raw["format"]; !ok || v == nil {
		plain.Format = "json_array"
	}
	*j = TransformerStepSpecExplode(plain)
	return nil
}

// A mapping transformer which can transform the message
type TransformerStepSpecMapping struct {
	// The source code of the mapping transformer
	Sourcecode string `json:"sourcecode" yaml:"sourcecode" mapstructure:"sourcecode"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecMapping) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sourcecode"]; raw != nil && !ok {
		return fmt.Errorf("field sourcecode in TransformerStepSpecMapping: required")
	}
	type Plain TransformerStepSpecMapping
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TransformerStepSpecMapping(plain)
	return nil
}

// A service transformer sends each message to a nats service to be transformed
type TransformerStepSpecService struct {
	// The nats subject on which the service is receiving requests
	Endpoint string `json:"endpoint" yaml:"endpoint" mapstructure:"endpoint"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The timeout for the service call
	Timeout string `json:"timeout,omitempty" yaml:"timeout,omitempty" mapstructure:"timeout,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecService) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["endpoint"]; raw != nil && !ok {
		return fmt.Errorf("field endpoint in TransformerStepSpecService: required")
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in TransformerStepSpecService: required")
	}
	type Plain TransformerStepSpecService
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		plain.Timeout = "5s"
	}
	*j = TransformerStepSpecService(plain)
	return nil
}
