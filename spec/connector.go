// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package spec

import "encoding/json"
import "fmt"

type ConnectorSpec struct {
	// A description of the connector
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The image to run
	Image string `json:"image" yaml:"image" mapstructure:"image"`

	// Metrics corresponds to the JSON schema field "metrics".
	Metrics *MetricsSpec `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`

	// Steps corresponds to the JSON schema field "steps".
	Steps StepsSpec `json:"steps" yaml:"steps" mapstructure:"steps"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectorSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ConnectorSpec: required")
	}
	if _, ok := raw["image"]; raw != nil && !ok {
		return fmt.Errorf("field image in ConnectorSpec: required")
	}
	if _, ok := raw["steps"]; raw != nil && !ok {
		return fmt.Errorf("field steps in ConnectorSpec: required")
	}
	type Plain ConnectorSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConnectorSpec(plain)
	return nil
}

// The consumer reading messages from NATS
type ConsumerStepSpec struct {
	// The JetStream configuration
	Jetstream *ConsumerStepSpecJetstream `json:"jetstream,omitempty" yaml:"jetstream,omitempty" mapstructure:"jetstream,omitempty"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The queue this connector should join
	Queue *string `json:"queue,omitempty" yaml:"queue,omitempty" mapstructure:"queue,omitempty"`

	// The subject to read messages from
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

// The JetStream configuration
type ConsumerStepSpecJetstream struct {
	// Whether to bind to the durable
	Bind *bool `json:"bind,omitempty" yaml:"bind,omitempty" mapstructure:"bind,omitempty"`

	// The JetStream deliver policy
	DeliverPolicy *string `json:"deliver_policy,omitempty" yaml:"deliver_policy,omitempty" mapstructure:"deliver_policy,omitempty"`

	// The durable name
	Durable *string `json:"durable,omitempty" yaml:"durable,omitempty" mapstructure:"durable,omitempty"`

	// The maximum number of acks pending
	MaxAckPending *int `json:"max_ack_pending,omitempty" yaml:"max_ack_pending,omitempty" mapstructure:"max_ack_pending,omitempty"`

	// The maximum ack wait time
	MaxAckWait *string `json:"max_ack_wait,omitempty" yaml:"max_ack_wait,omitempty" mapstructure:"max_ack_wait,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in ConsumerStepSpec: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ConsumerStepSpec: required")
	}
	type Plain ConsumerStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpec(plain)
	return nil
}

// The producer writing messages to NATS
type ProducerStepSpec struct {
	// The JetStream configuration
	Jetstream *ProducerStepSpecJetstream `json:"jetstream,omitempty" yaml:"jetstream,omitempty" mapstructure:"jetstream,omitempty"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The subject to write messages to
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`

	// The number of threads used to write messages.
	Threads int `json:"threads,omitempty" yaml:"threads,omitempty" mapstructure:"threads,omitempty"`
}

// The JetStream configuration
type ProducerStepSpecJetstream struct {
	// The ack wait time
	AckWait *string `json:"ack_wait,omitempty" yaml:"ack_wait,omitempty" mapstructure:"ack_wait,omitempty"`

	// The Batching Policy
	Batching *ProducerStepSpecJetstreamBatching `json:"batching,omitempty" yaml:"batching,omitempty" mapstructure:"batching,omitempty"`

	// The message id to allow stream message deduplication
	MsgId *string `json:"msg_id,omitempty" yaml:"msg_id,omitempty" mapstructure:"msg_id,omitempty"`
}

// The Batching Policy
type ProducerStepSpecJetstreamBatching struct {
	// The size of the batch
	ByteSize *int `json:"byte_size,omitempty" yaml:"byte_size,omitempty" mapstructure:"byte_size,omitempty"`

	// The number of messages to batch
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in ProducerStepSpec: required")
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ProducerStepSpec: required")
	}
	type Plain ProducerStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["threads"]; !ok || v == nil {
		plain.Threads = 1.0
	}
	*j = ProducerStepSpec(plain)
	return nil
}

// The external system that is the target for the messages
type SinkStepSpec struct {
	// The configuration of the sink step
	Config SinkStepSpecConfig `json:"config" yaml:"config" mapstructure:"config"`

	// The type of the sink step. This should be a sink that is included in the
	// connector's runtime
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// The configuration of the sink step
type SinkStepSpecConfig map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SinkStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in SinkStepSpec: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SinkStepSpec: required")
	}
	type Plain SinkStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SinkStepSpec(plain)
	return nil
}

// The external system that is the source of the messages
type SourceStepSpec struct {
	// The configuration of the source step
	Config SourceStepSpecConfig `json:"config" yaml:"config" mapstructure:"config"`

	// The type of the source step. This should be a source that is included in the
	// connector's runtime
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// The configuration of the source step
type SourceStepSpecConfig map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in SourceStepSpec: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SourceStepSpec: required")
	}
	type Plain SourceStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SourceStepSpec(plain)
	return nil
}

type StepsSpec struct {
	// Consumer corresponds to the JSON schema field "consumer".
	Consumer *ConsumerStepSpec `json:"consumer,omitempty" yaml:"consumer,omitempty" mapstructure:"consumer,omitempty"`

	// Producer corresponds to the JSON schema field "producer".
	Producer *ProducerStepSpec `json:"producer,omitempty" yaml:"producer,omitempty" mapstructure:"producer,omitempty"`

	// Sink corresponds to the JSON schema field "sink".
	Sink *SinkStepSpec `json:"sink,omitempty" yaml:"sink,omitempty" mapstructure:"sink,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *SourceStepSpec `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Transformer corresponds to the JSON schema field "transformer".
	Transformer *TransformerStepSpec `json:"transformer,omitempty" yaml:"transformer,omitempty" mapstructure:"transformer,omitempty"`
}

// The transformer for messages flowing through the connector
type TransformerStepSpec struct {
	// A composite transformer which can be used to combine several transformers
	Composite *TransformerStepSpecComposite `json:"composite,omitempty" yaml:"composite,omitempty" mapstructure:"composite,omitempty"`

	// A mapping transformer which can transform the message
	Mapping *TransformerStepSpecMapping `json:"mapping,omitempty" yaml:"mapping,omitempty" mapstructure:"mapping,omitempty"`

	// A service transformer sends each message to a nats service to be transformed
	Service *TransformerStepSpecService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

// A composite transformer which can be used to combine several transformers
type TransformerStepSpecComposite struct {
	// Sequential corresponds to the JSON schema field "sequential".
	Sequential []TransformerStepSpec `json:"sequential" yaml:"sequential" mapstructure:"sequential"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecComposite) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sequential"]; raw != nil && !ok {
		return fmt.Errorf("field sequential in TransformerStepSpecComposite: required")
	}
	type Plain TransformerStepSpecComposite
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TransformerStepSpecComposite(plain)
	return nil
}

// A mapping transformer which can transform the message
type TransformerStepSpecMapping struct {
	// The source code of the mapping transformer
	Sourcecode string `json:"sourcecode" yaml:"sourcecode" mapstructure:"sourcecode"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecMapping) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sourcecode"]; raw != nil && !ok {
		return fmt.Errorf("field sourcecode in TransformerStepSpecMapping: required")
	}
	type Plain TransformerStepSpecMapping
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TransformerStepSpecMapping(plain)
	return nil
}

// A service transformer sends each message to a nats service to be transformed
type TransformerStepSpecService struct {
	// The nats subject on which the service is receiving requests
	Endpoint string `json:"endpoint" yaml:"endpoint" mapstructure:"endpoint"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The timeout for the service call
	Timeout string `json:"timeout,omitempty" yaml:"timeout,omitempty" mapstructure:"timeout,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecService) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["endpoint"]; raw != nil && !ok {
		return fmt.Errorf("field endpoint in TransformerStepSpecService: required")
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in TransformerStepSpecService: required")
	}
	type Plain TransformerStepSpecService
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		plain.Timeout = "5s"
	}
	*j = TransformerStepSpecService(plain)
	return nil
}
