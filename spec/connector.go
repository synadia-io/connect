// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package spec

import "encoding/json"
import "fmt"

type ConnectorSpec struct {
	// A description of the connector
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// Id of the runtime to use for this connector
	RuntimeId string `json:"runtime_id" yaml:"runtime_id" mapstructure:"runtime_id"`

	// Steps corresponds to the JSON schema field "steps".
	Steps StepsSpec `json:"steps" yaml:"steps" mapstructure:"steps"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectorSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ConnectorSpec: required")
	}
	if _, ok := raw["runtime_id"]; raw != nil && !ok {
		return fmt.Errorf("field runtime_id in ConnectorSpec: required")
	}
	if _, ok := raw["steps"]; raw != nil && !ok {
		return fmt.Errorf("field steps in ConnectorSpec: required")
	}
	type Plain ConnectorSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConnectorSpec(plain)
	return nil
}

// The consumer reading messages from NATS
type ConsumerStepSpec struct {
	// The configuration for reading from Core NATS subjects
	Core *ConsumerStepSpecCore `json:"core,omitempty" yaml:"core,omitempty" mapstructure:"core,omitempty"`

	// The configuration for reading from the NATS KV store
	Kv *ConsumerStepSpecKv `json:"kv,omitempty" yaml:"kv,omitempty" mapstructure:"kv,omitempty"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The configuration for reading from JetStream streams
	Stream *ConsumerStepSpecStream `json:"stream,omitempty" yaml:"stream,omitempty" mapstructure:"stream,omitempty"`
}

// The configuration for reading from Core NATS subjects
type ConsumerStepSpecCore struct {
	// The queue this connector should join
	Queue *string `json:"queue,omitempty" yaml:"queue,omitempty" mapstructure:"queue,omitempty"`

	// The subject to read messages from
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpecCore) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ConsumerStepSpecCore: required")
	}
	type Plain ConsumerStepSpecCore
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpecCore(plain)
	return nil
}

// The configuration for reading from the NATS KV store
type ConsumerStepSpecKv struct {
	// The bucket to use when reading from the KV store
	Bucket string `json:"bucket" yaml:"bucket" mapstructure:"bucket"`

	// The prefix to use when reading from the KV store
	Prefix *string `json:"prefix,omitempty" yaml:"prefix,omitempty" mapstructure:"prefix,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpecKv) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bucket"]; raw != nil && !ok {
		return fmt.Errorf("field bucket in ConsumerStepSpecKv: required")
	}
	type Plain ConsumerStepSpecKv
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpecKv(plain)
	return nil
}

// The configuration for reading from JetStream streams
type ConsumerStepSpecStream struct {
	// The subject filter to apply to the messages
	Filter *string `json:"filter,omitempty" yaml:"filter,omitempty" mapstructure:"filter,omitempty"`

	// The stream to read messages from
	Stream string `json:"stream" yaml:"stream" mapstructure:"stream"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpecStream) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["stream"]; raw != nil && !ok {
		return fmt.Errorf("field stream in ConsumerStepSpecStream: required")
	}
	type Plain ConsumerStepSpecStream
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpecStream(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsumerStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in ConsumerStepSpec: required")
	}
	type Plain ConsumerStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConsumerStepSpec(plain)
	return nil
}

// The producer writing messages to NATS
type ProducerStepSpec struct {
	// The configuration for writing to Core NATS subjects
	Core *ProducerStepSpecCore `json:"core,omitempty" yaml:"core,omitempty" mapstructure:"core,omitempty"`

	// The configuration for writing to the NATS KV store
	Kv *ProducerStepSpecKv `json:"kv,omitempty" yaml:"kv,omitempty" mapstructure:"kv,omitempty"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The configuration for writing to JetStream streams
	Stream *ProducerStepSpecStream `json:"stream,omitempty" yaml:"stream,omitempty" mapstructure:"stream,omitempty"`

	// The number of threads used to write messages.
	Threads int `json:"threads,omitempty" yaml:"threads,omitempty" mapstructure:"threads,omitempty"`
}

// The configuration for writing to Core NATS subjects
type ProducerStepSpecCore struct {
	// The subject to send data to
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpecCore) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["subject"]; raw != nil && !ok {
		return fmt.Errorf("field subject in ProducerStepSpecCore: required")
	}
	type Plain ProducerStepSpecCore
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProducerStepSpecCore(plain)
	return nil
}

// The configuration for writing to the NATS KV store
type ProducerStepSpecKv struct {
	// The bucket to use when writing to the KV store
	Bucket string `json:"bucket" yaml:"bucket" mapstructure:"bucket"`

	// The key to use when writing to the KV store
	Key string `json:"key" yaml:"key" mapstructure:"key"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpecKv) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bucket"]; raw != nil && !ok {
		return fmt.Errorf("field bucket in ProducerStepSpecKv: required")
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in ProducerStepSpecKv: required")
	}
	type Plain ProducerStepSpecKv
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProducerStepSpecKv(plain)
	return nil
}

// The configuration for writing to JetStream streams
type ProducerStepSpecStream struct {
	// The subject to send data to
	Subject *string `json:"subject,omitempty" yaml:"subject,omitempty" mapstructure:"subject,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProducerStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in ProducerStepSpec: required")
	}
	type Plain ProducerStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["threads"]; !ok || v == nil {
		plain.Threads = 1.0
	}
	*j = ProducerStepSpec(plain)
	return nil
}

// The external system that is the target for the messages
type SinkStepSpec struct {
	// The configuration of the sink step
	Config SinkStepSpecConfig `json:"config" yaml:"config" mapstructure:"config"`

	// The type of the sink step. This should be a sink that is included in the
	// connector's runtime
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// The configuration of the sink step
type SinkStepSpecConfig map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SinkStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in SinkStepSpec: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SinkStepSpec: required")
	}
	type Plain SinkStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SinkStepSpec(plain)
	return nil
}

// The external system that is the source of the messages
type SourceStepSpec struct {
	// The configuration of the source step
	Config SourceStepSpecConfig `json:"config" yaml:"config" mapstructure:"config"`

	// The type of the source step. This should be a source that is included in the
	// connector's runtime
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// The configuration of the source step
type SourceStepSpecConfig map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceStepSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in SourceStepSpec: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SourceStepSpec: required")
	}
	type Plain SourceStepSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SourceStepSpec(plain)
	return nil
}

type StepsSpec struct {
	// Consumer corresponds to the JSON schema field "consumer".
	Consumer *ConsumerStepSpec `json:"consumer,omitempty" yaml:"consumer,omitempty" mapstructure:"consumer,omitempty"`

	// Producer corresponds to the JSON schema field "producer".
	Producer *ProducerStepSpec `json:"producer,omitempty" yaml:"producer,omitempty" mapstructure:"producer,omitempty"`

	// Sink corresponds to the JSON schema field "sink".
	Sink *SinkStepSpec `json:"sink,omitempty" yaml:"sink,omitempty" mapstructure:"sink,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *SourceStepSpec `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Transformer corresponds to the JSON schema field "transformer".
	Transformer *TransformerStepSpec `json:"transformer,omitempty" yaml:"transformer,omitempty" mapstructure:"transformer,omitempty"`
}

// The transformer for messages flowing through the connector
type TransformerStepSpec struct {
	// A composite transformer which can be used to combine several transformers
	Composite *TransformerStepSpecComposite `json:"composite,omitempty" yaml:"composite,omitempty" mapstructure:"composite,omitempty"`

	// A mapping transformer which can transform the message
	Mapping *TransformerStepSpecMapping `json:"mapping,omitempty" yaml:"mapping,omitempty" mapstructure:"mapping,omitempty"`

	// A service transformer sends each message to a nats service to be transformed
	Service *TransformerStepSpecService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

// A composite transformer which can be used to combine several transformers
type TransformerStepSpecComposite struct {
	// Sequential corresponds to the JSON schema field "sequential".
	Sequential []TransformerStepSpec `json:"sequential" yaml:"sequential" mapstructure:"sequential"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecComposite) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sequential"]; raw != nil && !ok {
		return fmt.Errorf("field sequential in TransformerStepSpecComposite: required")
	}
	type Plain TransformerStepSpecComposite
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TransformerStepSpecComposite(plain)
	return nil
}

// A mapping transformer which can transform the message
type TransformerStepSpecMapping struct {
	// The source code of the mapping transformer
	Sourcecode string `json:"sourcecode" yaml:"sourcecode" mapstructure:"sourcecode"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecMapping) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sourcecode"]; raw != nil && !ok {
		return fmt.Errorf("field sourcecode in TransformerStepSpecMapping: required")
	}
	type Plain TransformerStepSpecMapping
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TransformerStepSpecMapping(plain)
	return nil
}

// A service transformer sends each message to a nats service to be transformed
type TransformerStepSpecService struct {
	// The nats subject on which the service is receiving requests
	Endpoint string `json:"endpoint" yaml:"endpoint" mapstructure:"endpoint"`

	// Nats corresponds to the JSON schema field "nats".
	Nats NatsConfigSpec `json:"nats" yaml:"nats" mapstructure:"nats"`

	// The timeout for the service call
	Timeout string `json:"timeout,omitempty" yaml:"timeout,omitempty" mapstructure:"timeout,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransformerStepSpecService) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["endpoint"]; raw != nil && !ok {
		return fmt.Errorf("field endpoint in TransformerStepSpecService: required")
	}
	if _, ok := raw["nats"]; raw != nil && !ok {
		return fmt.Errorf("field nats in TransformerStepSpecService: required")
	}
	type Plain TransformerStepSpecService
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		plain.Timeout = "5s"
	}
	*j = TransformerStepSpecService(plain)
	return nil
}
